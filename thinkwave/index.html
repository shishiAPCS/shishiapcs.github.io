<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RosterFlow ‚Äî ThinkWave Organizer</title>
<style>
  :root{
    --bg:#0f1420; --panel:#171e2b; --soft:#1e2636; --text:#eaf0ff; --muted:#aab6d6; --chip:#202a3f; --accent:#5aa7ff; --ok:#3ccf8e; --warn:#f0a93b; --bad:#ff6b6b; --stroke:#23304a;
  }
  [data-theme="light"]{
    --bg:#f6f7fb; --panel:#ffffff; --soft:#f1f4fa; --text:#0b1322; --muted:#46546f; --chip:#e9eef7; --accent:#2a7fff; --ok:#0fa36b; --warn:#cb7a12; --bad:#d94242; --stroke:#dde3ef;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
  .page{max-width:1160px;margin:28px auto;padding:0 16px}
  header{display:flex;align-items:center;gap:10px;margin-bottom:18px}
  .brand{display:flex;align-items:center;gap:12px}
  .brand .logo{width:24px;height:24px;display:grid;place-items:center;border-radius:8px;background:linear-gradient(180deg,var(--accent),#6fe3ff)}
  .brand h1{font-size:18px;margin:0}
  .subtitle{opacity:.6}
  .spacer{flex:1}
  .theme{display:inline-flex;align-items:center;gap:8px;background:var(--soft);border:1px solid var(--stroke);border-radius:999px;padding:6px 10px}
  .theme button{background:none;border:0;color:var(--text);opacity:.7;padding:4px 8px;border-radius:8px;cursor:pointer}
  .theme button.active{opacity:1;background:var(--chip)}

  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:14px;padding:16px}
  .card h2{font-size:16px;margin:0 0 12px 0}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  .btn{background:var(--soft);border:1px solid var(--stroke);color:var(--text);border-radius:10px;padding:8px 10px;cursor:pointer}
  .btn:hover{filter:brightness(1.05)}
  .btn.tonal{background:var(--chip)}
  .btn.toggle-on{outline:2px solid var(--accent)}
  .chips{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 12px}
  .chip{padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);background:var(--chip);cursor:pointer;opacity:.9}
  .chip.active{outline:2px solid var(--accent);opacity:1}

  /* Tabs */
  .tabs{display:flex;gap:8px;margin:0 0 10px 0}
  .tab{background:var(--soft);border:1px solid var(--stroke);border-radius:10px;padding:6px 10px;cursor:pointer;opacity:.8}
  .tab.active{opacity:1;background:var(--chip);outline:2px solid var(--accent)}

  .roster{display:flex;flex-direction:column;gap:8px;max-height:280px;overflow:auto;border:1px solid var(--stroke);border-radius:10px}
  .row{display:flex;justify-content:space-between;gap:8px;padding:10px 12px;background:var(--soft);border-bottom:1px solid var(--stroke)}
  .row:last-child{border-bottom:0}
  .hint{font-size:12px;color:var(--muted);margin:10px 0}
  textarea{width:100%;min-height:160px;resize:vertical;border-radius:10px;background:var(--soft);border:1px solid var(--stroke);color:var(--text);padding:10px;font:13px/1.5 ui-monospace,SFMono-Regular,Consolas,Monaco,Menlo,monospace}
  .smallbox{min-height:110px}
  .rowctrls{display:flex;gap:8px;margin-top:8px}

  .kpis{display:flex;gap:10px;margin-top:8px;align-items:center;flex-wrap:wrap}
  .pill{font-size:12px;padding:6px 8px;border-radius:999px;border:1px solid var(--stroke);background:var(--soft);display:inline-flex;gap:6px;align-items:center}
  .ok{background:rgba(60,207,142,.12);border-color:rgba(60,207,142,.4)}
  .bad{background:rgba(255,107,107,.12);border-color:rgba(255,107,107,.4)}
  .warn{background:rgba(240,169,59,.12);border-color:rgba(240,169,59,.4)}

  details{margin-top:6px}
  details pre{background:var(--soft);border:1px solid var(--stroke);border-radius:10px;padding:10px;white-space:pre-wrap;word-break:break-word}

  .full{grid-column:1/-1}
  .preview{min-height:140px}
  .footer{opacity:.6;font-size:12px;margin-top:10px}
  .right{display:flex;justify-content:flex-end}

  .toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%) scale(.98);background:var(--panel);color:var(--text);border:1px solid var(--stroke);padding:10px 14px;border-radius:10px;opacity:0;pointer-events:none;transition:opacity .2s, transform .2s;z-index:800}
  .toast.show{opacity:1;transform:translateX(-50%) scale(1)}

  /* Paste-Order */
  .orderbar{display:flex;align-items:center;gap:8px;margin:6px 0 10px}
  .orderbadge{font-size:12px;padding:4px 8px;border-radius:999px;border:1px dashed var(--stroke);opacity:.8}
  .orderbadge.custom{border-style:solid}
  .orderarea{display:none;margin:8px 0}
  .orderarea.active{display:block}
  .switch{display:inline-flex;align-items:center;gap:6px}
  .switch input{accent-color:var(--accent)}

  /* Ad-hoc area (left card) */
  .adhoc{display:none}
  .adhoc.active{display:block}

  @media (max-width:920px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="page">
  <header>
    <div class="brand">
      <div class="logo">üîÅ</div>
      <div>
        <h1 style="margin:0">RosterFlow</h1>
        <div class="subtitle">ThinkWave Organizer</div>
      </div>
    </div>
    <div class="spacer"></div>
    <div class="theme" id="themeCtl" title="Theme">
      <!-- Auto button removed by request -->
      <button data-mode="light" title="Light">‚òÄÔ∏è&nbsp;Light</button>
      <button data-mode="dark"  title="Dark">üåô&nbsp;Dark</button>
    </div>
  </header>

  <div class="grid">
    <!-- Left: Roster / Ad-hoc -->
    <section class="card" id="cardRoster">
      <h2>1) Roster</h2>

      <!-- Tabs -->
      <div class="tabs" id="modeTabs">
        <button class="tab active" data-mode="subjects">Subjects</button>
        <button class="tab" data-mode="adhoc">Ad-hoc list</button>
      </div>

      <!-- Subjects mode -->
      <div class="subjects">
        <div class="toolbar">
          <label class="btn" for="fileJson">Import JSON</label>
          <input type="file" id="fileJson" accept="application/json" hidden />
          <!-- Use Cached removed; Clear Cache remains -->
          <button class="btn" id="btnClearCache">Clear Cache</button>
          <button class="btn" id="btnPasteOrder">Paste Roster Order</button>
        </div>
        <div class="chips" id="subjectChips"></div>

        <div class="orderbar">
          <span id="orderStatus" class="orderbadge">Order: Default</span>
          <div class="spacer"></div>
          <label class="switch"><input type="checkbox" id="onlyThese"> Only these</label>
          <button class="btn" id="btnClearOrder" title="Clear custom order">Clear order</button>
        </div>

        <div class="orderarea" id="orderArea">
          <div class="hint">One student per line. Any of these are fine:
            <code>Li, Xiaoduan "Minato"</code> ¬∑ <code>Minato Li</code> ¬∑ <code>Li Minato</code> ¬∑ <code>Minato</code> ¬∑ <code>Tom Z</code> ¬∑ <code>TomZ</code></div>
          <textarea class="smallbox" id="orderInput" placeholder="Minato&#10;Joe&#10;George&#10;..."></textarea>
          <div class="rowctrls right">
            <button class="btn" id="btnApplyOrder">Use this order</button>
          </div>
        </div>
      </div>

      <!-- Ad-hoc mode -->
      <div class="adhoc" id="adhocArea">
        <div class="hint">Paste a standalone list (one per line). This becomes the entire roster &amp; order. Autofill is disabled in this mode.</div>
        <textarea class="smallbox" id="adhocInput" placeholder="Alice&#10;Bob&#10;Charlie&#10;..."></textarea>
        <div class="rowctrls right">
          <button class="btn" id="btnUseAdhoc">Use this list</button>
        </div>
      </div>

      <div class="roster" id="rosterList"></div>
    </section>

    <!-- Right: Scores Paste -->
    <section class="card" id="cardScores">
      <h2>2) Paste Scores</h2>
      <div class="hint">Accepts <b>Name,Score</b> ¬∑ <b>Name Score</b> ¬∑ <b>Name ‚Ä¶ Score</b>. The last number on each line is used.</div>
      <textarea id="scoresInput" placeholder="Joe 99&#10;Selina 55&#10;George 77&#10;..."></textarea>
      <div class="rowctrls">
        <button class="btn" id="btnOrganize">Organize into Roster Order</button>
        <button class="btn tonal" id="btnToefl" title="Non-destructive toggle">TOEFL ‚Üí GPA (view)</button>
      </div>
      <div class="kpis">
        <div class="pill ok"   id="kMatch">‚úî Matched 0 of 0 parsed</div>
        <div class="pill warn" id="kAmb">‚ùì Ambiguous 0</div>
        <div class="pill bad"  id="kUnmatch">‚ùó Unmatched 0</div>
      </div>
      <details id="detailBox"><summary>See ambiguous/unmatched details</summary>
        <pre id="detailText"></pre>
      </details>
    </section>

    <!-- Bottom full: Results -->
    <section class="card full">
      <h2>3) Results</h2>
      <div class="hint">CSV Preview</div>
      <textarea class="preview" id="csvOut" readonly></textarea>
      <div class="rowctrls">
        <button class="btn" id="btnDownload">Download CSV</button>
      </div>
      <div class="footer">Tip: Open ThinkWave assignment page ‚Üí Right-click ‚Üí Inspect ‚Üí Console ‚Üí Cmd/Ctrl+V ‚Üí Enter.</div>
    </section>
  </div>
</div>

<div class="toast" id="toast">Copied to clipboard</div>

<script>
(() => {
  // THEME /////////////////////////////////////////////////////////////////
  const themeCtl = document.getElementById('themeCtl');
  const themeBtns = [...themeCtl.querySelectorAll('button')];
  const lsKeyTheme = 'rf_theme_pref';
  const setTheme = (mode) => {
    document.documentElement.removeAttribute('data-theme');
    if (mode === 'dark') document.documentElement.setAttribute('data-theme','dark');
    if (mode === 'light') document.documentElement.setAttribute('data-theme','light');
    localStorage.setItem(lsKeyTheme, mode);
    themeBtns.forEach(b=>b.classList.toggle('active', b.dataset.mode===mode));
  };
  themeCtl.addEventListener('click', (e)=> {
    const b = e.target.closest('button'); if (!b) return;
    setTheme(b.dataset.mode);
  });
  setTheme(localStorage.getItem(lsKeyTheme)||'auto'); // default to system (no button for auto)

  // GLOBAL STATE //////////////////////////////////////////////////////////
  const els = {
    chips: document.getElementById('subjectChips'),
    rosterList: document.getElementById('rosterList'),
    file: document.getElementById('fileJson'),
    clearCache: document.getElementById('btnClearCache'),
    scoresInput: document.getElementById('scoresInput'),
    btnOrganize: document.getElementById('btnOrganize'),
    btnToefl: document.getElementById('btnToefl'),
    csvOut: document.getElementById('csvOut'),
    btnDownload: document.getElementById('btnDownload'),
    detailBox: document.getElementById('detailBox'),
    detailText: document.getElementById('detailText'),
    kMatch: document.getElementById('kMatch'),
    kAmb: document.getElementById('kAmb'),
    kUn: document.getElementById('kUnmatch'),
    // Subjects mode
    btnPasteOrder: document.getElementById('btnPasteOrder'),
    orderArea: document.getElementById('orderArea'),
    orderInput: document.getElementById('orderInput'),
    orderStatus: document.getElementById('orderStatus'),
    btnApplyOrder: document.getElementById('btnApplyOrder'),
    btnClearOrder: document.getElementById('btnClearOrder'),
    onlyThese: document.getElementById('onlyThese'),
    // Tabs + Ad-hoc
    tabs: document.getElementById('modeTabs'),
    adhocArea: document.getElementById('adhocArea'),
    adhocInput: document.getElementById('adhocInput'),
    btnUseAdhoc: document.getElementById('btnUseAdhoc'),
  };

  const cacheKey = 'tw_rosters_v1';
  let data = null;            // loaded JSON
  let mode = 'subjects';      // 'subjects' | 'adhoc'
  let activeSubject = null;   // subject object
  let roster = [];            // current roster (subject or ad-hoc)
  let rosterKeys = [];        // Set<string>[] for matching
  let orderOverride = null;   // {lines:string[], only:boolean, map:int[]}
  let toeflOn = false;        // non-destructive toggle

  // UTIL /////////////////////////////////////////////////////////////////
  const toast = (msg) => { const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1400); };
  const tidy = (s) => (s||'').toString().replace(/[\u201C\u201D\u2018\u2019]/g,'"').replace(/[\t\r]/g,' ').replace(/\s+/g,' ').trim();
  const letters = (s) => (s||'').toLowerCase().normalize('NFD').replace(/[^a-z0-9]/g,'');
  const lastNumber = (line) => { const m = String(line).match(/(-?\d+(?:\.\d+)?)(?!.*\d)/); return m?m[1]:''; };

  const kFromStudent = (st) => {
    const disp = tidy(st.display||'');
    const eng = tidy(st.english||'');
    const fam = tidy(st.family||'');
    const giv = tidy(st.given||'');
    const keys = new Set();
    if (st.key) keys.add(letters(st.key));
    const q = disp.match(/"(.*?)"/); const nick = q ? tidy(q[1]) : '';
    const main = disp.replace(/".*?"/g,'').replace(/\s+,\s+/g,',').trim();
    let fam2=fam, giv2=giv;
    if (!fam2 || !giv2){
      if (main.includes(',')){ const parts = main.split(',').map(s=>s.trim()).filter(Boolean); fam2=fam2||parts[0]||''; giv2=giv2||parts[1]||''; }
      else { const parts = main.split(/\s+/); fam2=fam2||(parts.pop()||''); giv2=giv2||parts.join(' '); }
    }
    const add=v=>{ v=(v||'').trim(); if(v) keys.add(letters(v)); };
    add(eng); add(nick);
    add(`${eng} ${fam2}`); add(`${eng}${fam2}`);
    add(`${giv2} ${fam2}`); add(`${fam2} ${giv2}`); add(`${giv2}${fam2}`); add(`${fam2}${giv2}`);
    if (fam2) add(`${eng} ${fam2[0]}`);
    return Array.from(keys);
  };

  const kFromAnyName = (raw) => {
    const s = tidy(raw);
    const q = s.match(/"(.*?)"/); const nick = q ? q[1] : '';
    const strip = s.replace(/".*?"/g,'').trim();
    let fam='', giv='', eng='';
    if (strip.includes(',')){
      const parts = strip.split(',').map(p=>p.trim());
      fam = parts[0]||''; giv = parts[1]||''; eng = parts[2]||'';
    } else {
      const parts = strip.split(/\s+/).filter(Boolean);
      if (parts.length>=2){ giv = parts.slice(0,-1).join(' '); fam = parts.slice(-1)[0]; }
      else { eng = strip; }
    }
    const set = new Set();
    const add=v=>{ v=(v||'').trim(); if(v) set.add(letters(v)); };
    add(eng||nick||strip);
    add(`${eng} ${fam}`); add(`${giv} ${fam}`); add(`${fam} ${giv}`);
    add(`${eng}${fam}`);  add(`${giv}${fam}`);
    if (fam) add(`${eng} ${fam[0]}`);
    return Array.from(set);
  };

  const buildKeysForAdhocName = (name) => new Set(kFromAnyName(name));

  const pickBestMatch = (nameRaw, rosterKeysArr) => {
    const keys = kFromAnyName(nameRaw);
    let hit = -1, multi = false;
    for (let i=0;i<rosterKeysArr.length;i++){
      const set = rosterKeysArr[i];
      for (const k of keys){ if (set.has(k)) { if (hit===-1) hit=i; else multi=true; } }
    }
    return {index: hit, ambiguous: multi};
  };

  const refreshRosterUI = () => {
    els.rosterList.innerHTML = '';
    roster.forEach(st => {
      const row = document.createElement('div'); row.className='row';
      const who = document.createElement('div'); who.textContent = st.display || `${st.family}, ${st.given}`;
      const eng = document.createElement('div'); eng.textContent = tidy(st.english||''); eng.style.opacity='.6';
      row.append(who, eng); els.rosterList.append(row);
    });
  };

  const buildRosterKeys = () => {
    rosterKeys = roster.map(st=> new Set(kFromStudent(st)) );
  };

  const loadSubjects = () => {
    els.chips.innerHTML = '';
    if (!data || !Array.isArray(data.subjects)) return;
    (data.subjects||[]).forEach((s)=>{
      const b = document.createElement('div'); b.className='chip'; b.textContent = s.name; b.dataset.sid=s.id;
      b.addEventListener('click', ()=>selectSubject(s.id));
      els.chips.append(b);
    });
  };

  const markActiveChip = (sid) => {
    [...els.chips.children].forEach(c=>c.classList.toggle('active', c.dataset.sid===sid));
  };

  const selectSubject = (sid) => {
    mode = 'subjects';
    toggleModeUI();
    activeSubject = (data.subjects||[]).find(s=>String(s.id)===String(sid));
    if (!activeSubject){ roster=[]; refreshRosterUI(); return; }
    roster = (activeSubject.roster||[]).filter(r=>r && (r.display||r.english||r.family));
    buildRosterKeys();
    markActiveChip(activeSubject.id);
    refreshRosterUI();
    readOrderOverride();
    updateOrderBadge();
    if (els.scoresInput.value.trim()) organize(false);
  };

  const updateOrderBadge = () => {
    if (mode==='adhoc'){
      els.orderStatus.textContent = 'Roster: Ad-hoc';
      els.orderStatus.classList.add('custom');
      return;
    }
    const has = orderOverride && Array.isArray(orderOverride.map) && orderOverride.map.length>0;
    els.orderStatus.textContent = has? 'Order: Custom' : 'Order: Default';
    els.orderStatus.classList.toggle('custom', has);
  };

  // MODE TOGGLING /////////////////////////////////////////////////////////
  function toggleModeUI(){
    // tabs visual
    [...els.tabs.querySelectorAll('.tab')].forEach(t=>t.classList.toggle('active', t.dataset.mode===mode));
    // show/hide blocks
    document.querySelector('.subjects').style.display = (mode==='subjects'?'block':'none');
    els.adhocArea.classList.toggle('active', mode==='adhoc');
    // reset badges
    updateOrderBadge();
  }

  els.tabs.addEventListener('click', (e)=>{
    const b = e.target.closest('.tab'); if(!b) return;
    mode = b.dataset.mode;
    toggleModeUI();
    if (mode==='adhoc'){
      activeSubject = null; // no subject context
      // Ad-hoc roster stays whatever user last pasted; build keys if present
      if (roster.length===0) { refreshRosterUI(); }
      els.orderArea.classList.remove('active'); // hide paste-order if open
    } else {
      // back to subjects; if we have data already, keep chips & roster
      if (data && !activeSubject && (data.subjects||[]).length){ markActiveChip(null); }
    }
    if (els.scoresInput.value.trim()) organize(false);
  });

  // ORDER OVERRIDE (subjects only) ////////////////////////////////////////
  const orderKeyForSubject = () => `order_override_${activeSubject?.id||'none'}`;
  const writeOrderOverride = () => { if (!activeSubject) return; localStorage.setItem(orderKeyForSubject(), JSON.stringify(orderOverride||{})); };
  const readOrderOverride = () => { if (!activeSubject) return; try { orderOverride = JSON.parse(localStorage.getItem(orderKeyForSubject())||'{}'); } catch { orderOverride = {}; } if (!orderOverride) orderOverride={}; els.onlyThese.checked = !!orderOverride.only; recomputeOrderMap(); };
  const clearOrderOverride = () => { orderOverride = null; if (activeSubject) localStorage.removeItem(orderKeyForSubject()); updateOrderBadge(); };

  const recomputeOrderMap = () => {
    if (mode!=='subjects'){ updateOrderBadge(); return; }
    if (!orderOverride || !Array.isArray(orderOverride.lines)) { orderOverride={}; updateOrderBadge(); return; }
    const used = new Set();
    const map = [];
    const unknown = [];
    let dup = [];
    orderOverride.lines.forEach(line=>{
      const {index, ambiguous} = pickBestMatch(line, rosterKeys);
      if (index===-1) { unknown.push(line); return; }
      if (used.has(index)) { dup.push(line); return; }
      used.add(index); map.push(index);
    });
    if (!orderOverride.only){ for(let i=0;i<roster.length;i++){ if(!used.has(i)) map.push(i);} }
    orderOverride.map = map; orderOverride.unknown = unknown; orderOverride.dup = dup;
    writeOrderOverride(); updateOrderBadge();
  };

  // SCORE PARSE & ORGANIZE //////////////////////////////////////////////
  const parseScores = (text) => {
    const lines = text.split(/\n+/).map(l=>l.trim()).filter(Boolean);
    const entries = [];
    for (const line of lines){
      const score = lastNumber(line);
      if (score==='') continue;
      const name = line.replace(new RegExp(score.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+"$"), '').trim().replace(/[ ,]+$/,'');
      if (!name) continue;
      entries.push({raw: line, name, score});
    }
    return entries;
  };

  const buildNameToScoreMap = (entries) => {
    const keyMap = new Map();
    const amb = [];
    const un = [];
    let matches = 0;
    for (const e of entries){
      const {index, ambiguous} = pickBestMatch(e.name, rosterKeys);
      if (index===-1){ un.push(`- ${e.name} (${e.score})`); continue; }
      if (ambiguous) amb.push(`- ${e.name} (${e.score}) ‚Üí multiple matches`);
      keyMap.set(index, e.score); matches++;
    }
    return {keyMap, matches, amb, un};
  };

  const toGpa = (x) => {
    const n = Math.max(0, Math.min(30, Number(x)||0));
    return Math.round(55 + (n/30)*(100-55));
  };

  const organize = (maybeCopy=true) => {
    // choose roster source: subjects or ad-hoc
    if (mode==='subjects' && !activeSubject){ toast('Load a roster first.'); return; }

    const rawEntries = parseScores(els.scoresInput.value);
    const entries = toeflOn ? rawEntries.map(e=>({ ...e, score:String(toGpa(e.score)) })) : rawEntries;

    // Build keys (ad-hoc roster uses ad-hoc names)
    if (mode==='adhoc'){
      // roster already built from ad-hoc list; keys built alongside
    }

    const {keyMap, matches, amb, un} = buildNameToScoreMap(entries);

    // Order:
    let orderIdx = [...Array(roster.length).keys()];
    if (mode==='subjects' && orderOverride && Array.isArray(orderOverride.map) && orderOverride.map.length) {
      orderIdx = orderOverride.map.slice();
    }

    // CSV
    let csv = 'Name,Score\n';
    for (const i of orderIdx){
      const st = roster[i];
      const nm = tidy(st.display||`${st.family}, ${st.given}`);
      const val = keyMap.has(i) ? keyMap.get(i) : '';
      const nameCsv = '"'+nm.replace(/"/g,'""')+'"';
      csv += `${nameCsv},${val}\n`;
    }
    els.csvOut.value = csv;

    // KPIs + details
    const det = [];
    if (toeflOn) det.push('TRANSFORM ‚Äî TOEFL ‚Üí GPA (preview only, input unchanged)\n');
    if (mode==='subjects' && orderOverride && (orderOverride.unknown?.length || orderOverride.dup?.length)){
      if (orderOverride.unknown?.length){ det.push('ORDER INPUT ‚Äî Unknown (ignored):'); orderOverride.unknown.forEach(x=>det.push(`- ${x}`)); det.push(''); }
      if (orderOverride.dup?.length){ det.push('ORDER INPUT ‚Äî Duplicates (last one kept):'); orderOverride.dup.forEach(x=>det.push(`- ${x}`)); det.push(''); }
    }
    if (amb.length){ det.push('SCORES INPUT ‚Äî Ambiguous:'); amb.forEach(x=>det.push(x)); det.push(''); }
    if (un.length){ det.push('SCORES INPUT ‚Äî Unmatched:'); un.forEach(x=>det.push(x)); }
    els.detailText.textContent = det.join('\n');

    els.kMatch.textContent = `‚úî Matched ${keyMap.size} of ${entries.length} parsed`;
    els.kAmb.textContent   = `‚ùì Ambiguous ${amb.length}`;
    els.kUn.textContent    = `‚ùó Unmatched ${un.length}`;

    // Autofill code only when a subject is selected (not in Ad-hoc)
    if (maybeCopy && mode==='subjects' && activeSubject){
      const code = buildAutofillCode(entries);
      navigator.clipboard.writeText(code).then(()=>toast('Autofill code copied ‚úì'));
    } else if (maybeCopy && mode==='adhoc') {
      toast('CSV updated ‚úì'); // no autofill in Ad-hoc mode
    }
  };

  // AUTOFILL CODE (payload guard against empty keys) //////////////////////
  const buildAutofillCode = (entries) => {
    const letters = s => (s||'').toLowerCase().normalize('NFD').replace(/[^a-z0-9]/g,'');
    const keysFromAnyName = (raw) => {
      const s = String(raw||'').replace(/[\u201C\u201D\u2018\u2019]/g,'"').trim();
      const q = s.match(/"(.*?)"/); const nick = q ? q[1].trim() : '';
      const strip = s.replace(/".*?"/g,'').trim();
      let fam='', giv='', eng='';
      if (strip.includes(',')){
        const parts = strip.split(',').map(p=>p.replace(/,+$/,'').trim()).filter(Boolean);
        fam = parts[0]||''; giv = parts[1]||''; eng = parts[2]||'';
      } else {
        const parts = strip.split(/\s+/).filter(Boolean);
        if (parts.length>=2){ giv = parts.slice(0,-1).join(' '); fam = parts.slice(-1)[0]; }
        else { eng = strip; }
      }
      const set = new Set(), add=v=>{ v=(v||'').trim(); if(v) set.add(letters(v)); };
      add(eng||nick||strip);
      add(`${eng} ${fam}`); add(`${giv} ${fam}`); add(`${fam} ${giv}`);
      add(`${eng}${fam}`);  add(`${giv}${fam}`);
      if (fam){ add(`${eng} ${fam[0]}`); add(`${giv} ${fam[0]}`); add(`${eng}${fam[0]}`); add(`${giv}${fam[0]}`); }
      return Array.from(set);
    };

    const obj = {};
    for (const e of entries){
      const ks = keysFromAnyName(e.name);
      if (!ks.length){ const k = letters(e.name); if (k) ks.push(k); }
      for (const k of ks){ if (k) obj[k] = String(e.score); } // empty-key guard
    }
    const payload = JSON.stringify(obj);

    return `
(() => {
  const norm = s => String(s||'').toLowerCase().normalize('NFD').replace(/[^a-z0-9]/g,'');
  const keyMap = ${payload};

  function parseDisp(disp){
    let d = String(disp||'').trim().replace(/\\s+/g,' ');
    const q = d.match(/["‚Äú](.*?)["‚Äù]/);
    let eng = q ? q[1].trim() : '';
    const withoutQuotes = d.replace(/".*?"/g,'').replace(/\\s*,\\s*$/,'').trim();
    let fam='', giv='';
    if (withoutQuotes.includes(',')){
      const parts = withoutQuotes.split(',').map(s => s.replace(/,+$/,'').trim()).filter(Boolean);
      fam = parts[0]||''; giv = parts[1]||'';
      if (!eng && parts.length>=3 && /^[A-Za-z .'-]+$/.test(parts[2])) eng = parts[2].trim();
    } else {
      const p = withoutQuotes.split(/\\s+/).filter(Boolean);
      fam = p.pop()||''; giv = p.join(' ');
    }
    return {fam,giv,eng};
  }

  function keysForDisp(disp){
    const {fam,giv,eng} = parseDisp(disp);
    const K = new Set(), add=v=>{ v=(v||'').trim(); if(v) K.add(norm(v)); };
    add(eng); add(giv);
    add(eng+' '+fam); add(eng+fam);
    add(giv+' '+fam); add(giv+fam);
    add(fam+' '+giv);
    if (fam){ add(eng+' '+fam[0]); add(giv+' '+fam[0]); add(eng+fam[0]); add(giv+fam[0]); }
    return K;
  }

  const rows = Array.from(document.querySelectorAll('.table-panel .table tbody tr, .table tbody tr'))
    .map(el => el.tagName==='TR' ? el : el.closest('tr')).filter(Boolean);

  let filled=0, matched=0, unmatched=0, seen=0;

  for (const tr of rows){
    if (tr.classList.contains('paddedquickfill') || tr.querySelector('#id_grade')) continue;
    const a = tr.querySelector('a[href*="/gp/st/"], a[href*="/st/"]'); if (!a) continue;
    seen++;
    const disp = (a.textContent||'').trim();
    const keys = keysForDisp(disp);
    let value='';
    for (const k of keys){ if (Object.prototype.hasOwnProperty.call(keyMap,k)) { value = keyMap[k]; break; } }
    const input = tr.querySelector('input[name$="-grade"], input.input-small.form-control[type="text"], input[type="text"]');
    if (input && value!==''){
      input.value = value;
      input.dispatchEvent(new Event('input',{bubbles:true}));
      input.dispatchEvent(new Event('change',{bubbles:true}));
      matched++; filled++;
    } else {
      unmatched++;
    }
  }
  console.log('[ThinkWave Autofill] rows:', seen, 'matched:', matched, 'filled:', filled, 'unmatched:', unmatched);
})();`.trim();
  };

  // DOWNLOAD /////////////////////////////////////////////////////////////
  const downloadCSV = () => {
    const now = new Date();
    const pad = n=>String(n).padStart(2,'0');
    const stamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
    const subj = tidy(activeSubject?.name || (mode==='adhoc' ? 'Adhoc' : 'Roster'));
    const name = `${subj.replace(/[^a-z0-9]+/gi,'_')}_${stamp}.csv`;
    const blob = new Blob([els.csvOut.value||''], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
  };

  // EVENTS ///////////////////////////////////////////////////////////////
  document.getElementById('btnDownload').addEventListener('click', downloadCSV);
  els.btnOrganize.addEventListener('click', ()=>organize(true));

  // Non-destructive TOEFL toggle
  els.btnToefl.addEventListener('click', ()=>{
    toeflOn = !toeflOn;
    els.btnToefl.classList.toggle('toggle-on', toeflOn);
    organize(false);
  });

  // Paste-order UI (subjects only)
  document.getElementById('btnPasteOrder').addEventListener('click', ()=>{ if(mode==='subjects') els.orderArea.classList.toggle('active'); });
  els.btnApplyOrder.addEventListener('click', ()=>{
    if (mode!=='subjects') return;
    const lines = els.orderInput.value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    orderOverride = {lines, only: els.onlyThese.checked};
    recomputeOrderMap();
    if (els.scoresInput.value.trim()) organize(false);
  });
  els.btnClearOrder.addEventListener('click', ()=>{ if(mode!=='subjects') return; clearOrderOverride(); organize(false); });
  els.onlyThese.addEventListener('change', ()=>{ if(mode==='subjects' && orderOverride){ orderOverride.only = els.onlyThese.checked; recomputeOrderMap(); organize(false);} });

  // Ad-hoc list handling
  els.btnUseAdhoc.addEventListener('click', ()=>{
    mode = 'adhoc';
    toggleModeUI();
    const names = els.adhocInput.value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    roster = names.map(n=>({ display: n }));
    rosterKeys = names.map(n => buildKeysForAdhocName(n));
    refreshRosterUI();
    if (els.scoresInput.value.trim()) organize(false);
  });

  // File input (subjects)
  els.file.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    try{
      const txt = await f.text(); const json = JSON.parse(txt);
      data = json; localStorage.setItem(cacheKey, JSON.stringify(json)); loadSubjects(); toast('JSON loaded ‚úì');
    }catch{ alert('Invalid JSON.'); }
  });

  // Clear cache
  els.clearCache.addEventListener('click', ()=>{ localStorage.removeItem(cacheKey);
    if (data?.subjects) data.subjects.forEach(s=> localStorage.removeItem(`order_override_${s.id}`));
    data=null; activeSubject=null; roster=[]; rosterKeys=[]; els.chips.innerHTML=''; refreshRosterUI(); toast('Cache cleared');
  });

  // INIT ‚Äî auto-hydrate cache if present
  (function init(){
    try{ const j = JSON.parse(localStorage.getItem(cacheKey)||'null'); if(j){ data=j; loadSubjects(); } }catch{}
    toggleModeUI();
  })();
})();
</script>
</body>
</html>
